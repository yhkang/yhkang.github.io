{"pages":[],"posts":[{"title":"JVM和垃圾回收","text":"总结了JVM的内存区域、垃圾回收算法、常用垃圾回收器，期待新的G1和ZGC。1. JVM 内存区域运行时数据区域堆和栈对象的内存布局和访问定位类加载检查分配内存：指针碰撞、空闲列表初始化零值设置对象头：类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息执行init方法句柄和直接引用内存参数设置和溢出溢出类型参数设置报错信息堆溢出-Xms-Xmxjava.lang.OutOfMemoryError: GC overhead limit exceeded 不断分配对象java.lang.OutOfMemoryError: Java heap space 分配巨型对象新生代配置-Xmn-XX:NewRatio-XX:SurvivorRatio方法区和运行时常量池溢出-XX:MetaspaceSize-XX:MaxMetaspaceSizejava.lang.OutOfMemoryError本地方法栈和虚拟机栈溢出-Xssjava.lang.StackOverflowError本机直接内存溢出-XX:MaxDirectMemorySizeException in thread &quot;main&quot; java.lang.OutOfMemoryError: Direct buffer memoryJDK提供的分析工具作用示例jps虚拟机进程状况工具jps [-q] [-mlvV]jstat虚拟机统计信息监视工具jstat -gcjstat -gccausejstat -gcutil &lt;pid&gt;jinfoJava配置信息工具jinfo -flags &lt;pid&gt;jinfo -sysprops &lt;pid&gt;jinfo -flag +PrintGC &lt;pid&gt;jmapJava内存映像工具jmap -dump:live,format=b,file=heap.bin &lt;pid&gt;jhat虚拟机堆转储快照分析工具分析jmap生成的转储文件jstackJava堆栈跟踪工具线程栈信息，死锁检测，Thread.getAllStackTraces()JConsoleJava监视与管理控制台JVisualVM多合一故障处理工具比jconsole更强大，支持插件jmc飞行记录器，监控数据比jvisualvm更加丰富2. 垃圾回收和内存分配策略Where回收谁：堆内存、常量池，引用类型When什么时候回收：内存空间不足、How怎么回收：GC算法判断对象存活原理优劣引用计数记录对象被引用次数，为0时则不可用方便简单，但存在相互引用的问题可达性分析以GC Roots作为起始点开始搜索，搜索路径称为引用链，对象不与引用链相连则此对象不可用GC Roots虚拟机栈中引用的对象本地方法栈中JNI引用的对象方法区中类型静态属性引用的对象方法区中常量引用的对象引用类型示例说明和回收时机强引用Object obj = new Object()软引用SoftReferenceSoftReference&lt;User&gt; user = new SoftReference&lt;&gt;(new User());有用非必需的对象，即将OOM之前被回收，用在内存资源紧张、缓存弱引用WeakReferenceWeakReference&lt;User&gt; user = new WeakReference&lt;&gt;(new User());稍微有用但非必需，GC发生即被回收，用在缓存、HashMap虚引用PhantomReference一般使用不上，析构函数finalize不建议使用通过虚引用无法拿到对象实例，被回收时收到一个通知垃圾回收算法工作原理优劣劣势Mark-Sweep标记清除算法先标记出需回收的对象，然后统一回收简单空间碎片Copying复制算法内存划分为两部分，将活着的对象复制到另一部分空间连续浪费一半空间、复制数据Mark-Compact标记整理算法先标记出需回收的对象，然后把向一端移动空间连续复制数据分代收集根据对象存活周期将内存分块，应用不同的收集算法：新生代：Eden : Survivor : Survivor = 8 : 1 : 1 复制算法，minor gc老年代：标记清除或标记整理，full gc垃圾回收器并行：垃圾收集的多线程的同时进行。并发：垃圾收集的多线程和应用的多线程同时进行。算法收集器类型特性和适用场景Serial GC新生代，复制算法单线程stop the world，简单高效ParNew新生代，复制算法并行多线程关注停顿时间，搭配CMS首选，适合用户交互Parallel Scavenge新生代，复制算法并行多线程关注吞吐量，适合后台任务Serial Old老年代，标记整理算法单线程Parallel Old老年代，标记整理算法并行多线程关注吞吐量，搭配Parallel ScavengeCMS老年代，标记清除算法并行并发关注停顿时间Serial + Serial Old :+1:单CPU基于串行回收的垃圾回收器适用于大多数对于暂停时间要求不高的 Client 模式下的 JVMParNew + Serial OldParallel Scavenge + Serial OldParallel Scavenge + Parallel Old :+1:高吞吐量程序吞吐量优先的应用场景中，在 Server 模式下内存回收的性能较为不错ParNew + CMS :+1:低停顿时间并发低延迟，吞吐量较低。经过CMS收集的堆会产生空间碎片，会带来堆内存的浪费初始标记 -&gt; 并发标记 -&gt; 重新标记 -&gt; 并发清除G1 :+1:全能型选手​基于并行和并发、低延迟以及暂停时间更加可控的区域化分代收集的垃圾回收器没有采用传统物理隔离的新生代和老年代的布局方式，仅仅以逻辑上划分为新生代和老年代，选择的将 Java 堆区划分为 2048 个大小相同的独立 Region 块参数新生代老年代适用场景-XX:+UseSerialGCSerialSerial Old单CPU-XX:+UseParNewGCParNewSerial Old-XX:+UseParallelGCParallel ScavengeSerial Old-XX:+UseParallerOldGCParallel ScavengeParallel Old后台计算，高吞吐量-XX:+UseConcMarkSweepGCParNewCMS用户交互，低停顿时间-XX:+UseG1GCStop The World暂停用户线程进行垃圾回收的现象。调优的目标就是尽可能的减少STW的时间和次数内存分配与回收策略对象优先在Eden分配：空间不足则Minor GC大对象直接进入老年代：如长字符串或大数组长期存活的对象进入老年代：默认15，-XX:MaxTenuringThreshold调整动态对象年龄判定：survivor中相同年龄的对象总和大于空间的一半时直接进入老年代空间分配担保：survivor空间不足，无法容纳的对象直接进入老年代，老年代的连续空间大于新生代对象的总大小或者历次晋升的平均大小，就进行Minor GC，否则FullGC内存泄漏、内存溢出OOM内存溢出：内存空间不足导致内存泄漏：该释放的对象没有释放GC调优的原则和步骤大部分的java应用不需要调优优先改善代码问题GC调优时最后的手段选择合适的GC收集器选择合适的堆大小选择合适的年轻代在堆中的占比步骤监控GC状态分析结果，判断是否要优化Minor GC时间 &lt;50ms, 频率10sFull GC时间执行时间 &lt;1s，频率10min","link":"/2019/12/28/JVM%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"},{"title":"JavaScript手册1","text":"作为后端开发，工作中也经常需要开发后台页面，而无论是使用哪种Web前端框架都是要使用JavaScript开发的。这门语言经过多年的发展，不仅出现了ES2015这样的现代JavaScript标准，也出现了TypeScript这样的具有类型系统且可编译为JavaScript代码的语言。之前写js代码基本就是参考着已有代码写，或者遇到不会的Google一下，这个月每天花二十分钟在excuteprogram上学习了js相关的4个课程（JavaScript Array、Modern JavaScript、TypeScript、Regex），都是基本的语法，好处是可以边学边练印象更深刻了。这里把常用的一些语法记录下备查。JavaScript ArrayBASICS123456&gt; a.lengtharray length &gt; a[i]get index i &gt; a[i] = xstore x at index iSTACK1234&gt; a.push(x)append x to array a &gt; a.pop()remove last element of aFOR EACH12&gt; a.forEach(f)call f on each elementSLICE123456&gt; [10,20,30].slice(1)[20, 30] &gt; [10,20,30].slice(1, 2)[20] &gt; a.slice()copy arrayMAP12&gt; a.map(f)[f(a[0]), f(a[1]), ...]SLICE WITH NEGATIVE ARGUMENTS1234&gt; [10, 20, 30, 40, 50].slice(-2)[40, 50] &gt; [10, 20, 30].slice(-3, -1)[10, 20]JOIN123456&gt; [1, 2].join()'1,2' &gt; [1, 2].join('')'12' &gt; [1, 2].join('_')'1_2'CONCAT12&gt; a1.concat(a2)combine two arraysINCLUDES1234&gt; [10, 20].includes(10)true &gt; [10, 20].includes(30)falseREDUCE12&gt; [1,2].reduce((sum, x) =&gt; sum + x)3INDEX OF12&gt; [10,20].indexOf(20)1NEW AND FILL123456&gt; new Array(2).length2 &gt; new Array(2)[0]undefined &gt; new Array(2).fill('a')['a', 'a']FILTER1234&gt; [1, 2].filter(x =&gt; x &gt; 1)[2] &gt; [1, 2].filter(x =&gt; x &lt; 3)[1, 2]SORT123456&gt; ['a', 'b'].sort()['a', 'b'] &gt; [10, 2].sort()[10, 2] &gt; [10, 2].sort((x, y) =&gt; x - y)[2, 10]FIND INDEX12&gt; [5, 6].findIndex(x =&gt; x === 6)1SOME AND EVERY1234&gt; [10, 20].some(x =&gt; x &gt; 10)true &gt; [10, 20].every(x =&gt; x &gt; 10)falseSHIFT1234&gt; a.shift()remove element 0 &gt; a.unshift(x)insert at element 0FIND1234&gt; [10, 20].find(x =&gt; x &gt; 10)20 &gt; [10, 20].find(x =&gt; x &lt; 0)undefinedREVERSE12&gt; [1, 2].reverse()[2, 1]REDUCE RIGHT12&gt; ['a','b'].reduceRight((a,x)=&gt;a+x)'ba'EMPTY SLOTS123456&gt; new Array(1)[0]undefined &gt; 0 in ['something']true &gt; 0 in new Array(1)falseFLAT AND FLATMAP123456789101112131415161718&gt; [ [1, 2], [3, 4] ].flat()[1, 2, 3, 4] &gt; [ [1, 2], [ 3, [4] ] ].flat(1)[1, 2, 3, [4]] &gt; [ {numbers: [1, 2]}, {numbers: [3, 4]}, ].flatMap(obj =&gt; obj.numbers)[1, 2, 3, 4]Modern JavaScriptModern JavaScript features, from ES5 (released in 2009) through ES2017STRICT MODE123456&gt; function defineX() { x = 1 return 'ok' } defineX()ReferenceError: x is not definedLET12345&gt; if (true) { let x = 1 } xReferenceError: x is not definedCONST123&gt; const x = 1 x = 2TypeError: Assignment to constant variable.FOR OF LOOPS1234567&gt; const letters = ['a', 'b', 'c'] const result = [] for (const letter of letters) { result.push(letter) } result['a', 'b', 'c']REST PARAMETERS12345&gt; function f(...args) { return args } f(1, 2, 3)[1, 2, 3]TEMPLATE LITERALS12&gt; `1 + 1 = ${1 + 1}`'1 + 1 = 2'ACCESSORS IN OBJECT LITERALS123456&gt; const user = { realName: 'Amir', get name() { return this.realName }, set name(newName) { this.realName = newName }, }undefinedBASIC ARRAY DESTRUCTURING12345678&gt; const letters = ['a', 'b', 'c'] const [a, b, c, d] = letters; [c, d]['c', undefined] &gt; const letters = ['a', 'b', 'c'] const [a, ...others] = letters others['b', 'c']COMPUTED PROPERTIES12345&gt; const loginCounts = { ['Be' + 'tty']: 7 } loginCounts.Betty7BASIC OBJECT DESTRUCTURING12345678&gt; const user = {name: 'Amir', email: 'amir@example.com', age: 36} const {name, age} = user; [name, age]['Amir', 36] &gt; const key = 'NaMe' const {[key.toLowerCase()]: value} = {name: 'Amir'} value'Amir'SHORTHAND PROPERTIES12345678&gt; const name = 'Amir' const catName = 'Ms. Fluff' const city = 'Paris' const age = 36 const user = {name, catName, city, age}; [user.name, user.age]['Amir', 36]DESTRUCTURING123456789&gt; function city({address: {city}}) { return city } city({name: 'Amir', address: {city: 'Paris'}})'Paris' &gt; const users = [{name: 'Amir'}, {name: 'Betty'}] const [, {name}] = users name'Betty'SHORTHAND METHODS1234567&gt; const address = { city: 'Paris', country: 'France', addressString() { return `${this.city}, ${this.country}` }, } address.addressString()'Paris, France'BIND1234567&gt; const user = {name: 'Amir'} function userName() { return this.name } const userNameBound = userName.bind(user) userNameBound()'Amir'ARROW FUNCTIONS123456789&gt; [1, 2, 3].map(x =&gt; x * 2)[2, 4, 6] &gt; const user = {name: 'Amir'} const getName = ({name}) =&gt; name getName(user)'Amir' &gt; const rest = (first, ...rest) =&gt; rest rest(1, 2, 3, 4)[2, 3, 4]CLASSES12345678910111213&gt; class Cat { constructor(name, vaccinated) { this.name = name this.vaccinated = vaccinated } needsVaccination() { return !this.vaccinated } } new Cat('Ms. Fluff', true).needsVaccination()falseEXTENDING CLASSES1234567891011121314&gt; class Animal { constructor(name) { this.name = name } } class Cat extends Animal { constructor(name) { super(name + ' the cat') } } new Cat('Ms. Fluff').name'Ms. Fluff the cat'FUNCTION NAME PROPERTY123456789&gt; ( function() { return 5 } ).name '' &gt; const f = function() { return 5 } const f2 = f f2.name'f'ANONYMOUS AND INLINE CLASSES12345678&gt; new ( class { speak() { return 'yaong' } } )().speak()'yaong'ACCESSOR PROPERTIES ON CLASSES1234567891011121314151617181920212223&gt; class User { constructor(name) { this.actualName = name } get name() { return `${this.actualName} the user` } } new User('Betty').name'Betty the user' &gt; class User { constructor(name) { this.actualName = name } set name(newName) { this.actualName = newName } } const user = new User('Amir') user.name = 'Betty' user.actualName'Betty'DEFAULT PARAMETERS12345&gt; function add(x, y=0) { return x + y } [add(1, 2), add(1)][3, 1]JSON STRINGIFY AND PARSE123456789101112&gt; JSON.stringify({a: 2}) === '{\"a\":2}'true &gt; JSON.parse('{\"a\": 1, \"b\" : 2}'){a: 1, b: 2} &gt; const user = { name: 'Amir', toJSON: () =&gt; 'This is Amir!' } JSON.parse(JSON.stringify(user))'This is Amir!'STRING KEYED METHODS12345&gt; const user = { 'name of the ~user~'() { return 'Betty' } } user['name of the ~user~']()'Betty'STATIC METHODS123456789101112131415&gt; class User { static getUserName(user) { return user.name } } User.getUserName({name: 'Amir'})'Amir' &gt; class User { static get defaultName() { return 'Amir' } } User.defaultName'Amir'COMPUTED METHODS AND ACCESSORS123456789101112&gt; class User { constructor(name) { this.name = name } get ['user' + 'Name']() { return this.name } } new User('Betty').userName'Betty'SYMBOL BASICS123456789101112&gt; Symbol('a') === Symbol('a')false &gt; const obj = {} obj[true] = 1 Object.keys(obj) ['true'] &gt; const nameSymbol = Symbol('name') const user = {[nameSymbol]: 'Amir'} user[nameSymbol]'Amir'SYMBOLS1234567891011121314151617&gt; class User { constructor(name) { this[Symbol.toStringTag] = name } } const user = new User('Amir') user.name = 'Betty' user.toString()'[object Amir]' &gt; const user = { name: 'Amir', [Symbol.toStringTag]: 'Amir' } JSON.parse(JSON.stringify(user)){name: 'Amir'}ISNAN12345678&gt; isNaN(undefined)true &gt; Number.isNaN(undefined)false &gt; Number.isNaN(NaN)trueNEW NUMBER METHODS12345678&gt; Number.isFinite(-Infinity)false &gt; Number.isSafeInteger(Number.MAX_SAFE_INTEGER + 1)false &gt; 2 ** 8256DEFINING ITERATORS12345678910111213&gt; const letters = ['a', 'b', 'c'] const iterator = letters[Symbol.iterator]() iterator.next() iterator.next(){done: false, value: 'b'} &gt; const letters = ['a', 'b', 'c'] const iterator = letters[Symbol.iterator]() iterator.next() iterator.next() iterator.next() iterator.next(){done: true, value: undefined}GENERATORS1234567&gt; function* numbersBelow(maximum) { for (let i=0; i&lt;maximum; i++) { yield i } } Array.from(numbersBelow(3))[0, 1, 2]PROBLEMS WITH OBJECT KEYS123456&gt; const obj = { [{key1: 'value1'}]: 1, [{key2: 'value2'}]: 2, } Object.keys(obj)['[object Object]']ITERATORS12345678910111213&gt; function* letters() { yield 'a' yield 'b' yield 'c' } const [, b, c] = letters(); [b, c] ['b', 'c'] &gt; const notAnIterator = 5 for (const x of notAnIterator) { }TypeError: notAnIterator is not iterableMAPS123456789101112&gt; const userEmails = new Map([ ['Amir', 'amir@example.com'], ['Betty', 'betty@example.com'] ]) userEmails.get('Betty')'betty@example.com' &gt; const emails = new Map() emails.set('Betty', 'betty.j@example.com') emails.set('Betty', 'betty.k@example.com') emails.get('Betty')'betty.k@example.com'SETS12345678910&gt; const names = new Set(['Amir', 'Betty', 'Cindy']) names.add('Dalili') names.has('Dalili')true &gt; const names = new Set(['Amir']) names.add('Betty') names.add('Betty') Array.from(names.values())['Amir', 'Betty']TAGGED TEMPLATE LITERALS123456789101112&gt; function doubleNumbers(strings, ...values) { let result = '' for (let i=0; i&lt;strings.length; i++) { result += strings[i] if (i &lt; values.length) { result += (2 * values[i]).toString() } } return result } doubleNumbers`the numbers ${1} and ${2}`'the numbers 2 and 4'SPREAD123456789101112131415161718&gt; const numbers = [ 1, ...[2, 3], 4, ] numbers[1, 2, 3, 4] &gt; const amir = { name: 'Amir', age: 36, } const amirWithEmail = { ...amir, email: 'amir@example.com' } amirWithEmail{age: 36, email: 'amir@example.com', name: 'Amir'}CLASS SCOPING12345678910111213141516&gt; function createGorilla(name) { class Gorilla { constructor() { this.name = name } } return new Gorilla() } createGorilla('Michael').name'Michael' &gt; if (true) { class Cat { } } new Cat()ReferenceError: Cat is not definedCUSTOMIZING JSON SERIALIZATION123456789101112131415161718192021222324252627282930313233&gt; JSON.parse( JSON.stringify( {name: 'Amir', age: 36, city: 'Paris'}, ['name', 'city'] ) ){city: 'Paris', name: 'Amir'} &gt; JSON.parse( JSON.stringify( {name: 'Amir', catName: 'Ms. Fluff', city: 'Paris'}, (key, value) =&gt; { if (key === 'catName') { return undefined } else { return value } } ) ){city: 'Paris', name: 'Amir'} &gt; JSON.parse( `{\"name\": \"Amir\", \"age\": 36}`, (key, value) =&gt; { if (key === 'age' &amp;&amp; value === 36) { return 'thirty six' } else { return value } } ){age: 'thirty six', name: 'Amir'}PROPERTY ORDER12345&gt; const user = {name: 'Amir', age: 36} user.email = 'amir@example.com' // Object keys come back in the order they were assigned. Object.keys(user)['name', 'age', 'email']MAP ITERATORS12345678910111213141516171819&gt; const catAges = new Map([ ['Ms. Fluff', 4], ['Keanu', 2], ]) Array.from(catAges.keys())['Ms. Fluff', 'Keanu'] &gt; const catAges = new Map([ ['Keanu', 2], ['Ms. Fluff', 4], ]) Array.from(catAges.values())[2, 4] &gt; const emails = new Map() emails.set('Amir', 'amir@example.com') emails.set('Betty', 'betty@example.com') Array.from(emails)[['Amir', 'amir@example.com'], ['Betty', 'betty@example.com']]SET OPERATIONS12345678910111213141516171819202122232425&gt; const set1 = new Set([1, 2, 3]) const set2 = new Set([2, 3, 4]) // Set union: all of the elements in either set. const unionSet = new Set([...set1, ...set2]); [unionSet.has(1), unionSet.has(4)] Array.from(unionSet)[1, 2, 3, 4] &gt; const set1 = new Set([1, 2, 3]) const set2 = new Set([2, 3, 4]) // Set intersection: all of the elements in both sets. const intersectionSet = new Set( Array.from(set1).filter(n =&gt; set2.has(n)) ); Array.from(intersectionSet)[2, 3] &gt; const set1 = new Set([1, 2, 3]) const set2 = new Set([2, 3, 4]) // Set difference: all of the elements in set1 but not set2. const differenceSet = new Set( Array.from(set1).filter(n =&gt; !set2.has(n)) ); Array.from(differenceSet)[1]","link":"/2020/04/28/JavaScript%E6%89%8B%E5%86%8C1/"},{"title":"JavaScript手册2——TypeScipt","text":"TypeScript是JavaScript的超集，为JavaScript 添加了可选的类型、类和模块系统。它可以编译成普通的JavaScript代码。 TypeScript支持任意浏览器，任意环境，任意系统并且是开源的。TypeScriptBASIC TYPES12&gt; let n: number = 2statically declare n as a number with the value 2.OPERATORS12&gt; 4 / '2'type error: The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.JAVASCRIPT BUILTINS12&gt; const n: number = (123).toString()type error: Type 'string' is not assignable to type 'number'.INFERENCE123&gt; let n = 2 + 2 let s: string = ntype error: Type 'number' is not assignable to type 'string'.FUNCTIONS12345678&gt; function numToString(x: number): string { return x.toString() }Declare numToString as a function taking a number and returning a string. &gt; function double(x: number): string { return 2 * x }type error: Type 'number' is not assignable to type 'string'.ARRAYS123&gt; let strings: string[] = ['a', 2] stringstype error: Type 'number' is not assignable to type 'string'.TYPE KEYWORD1234&gt; type MyStringType = string let s: MyStringType = 'hello' s'hello'SYNTAX ERRORS VS TYPE ERRORS12&gt; 1 &amp;+@ 2syntax error: Expression expected.OBJECT TYPES123456&gt; type User = { email: string, } let amir: User = {email: 'amir@example.com'} amir.email'amir@example.com'RETURN TYPE INFERENCE12345&gt; function two() { return 1 + 1 } let s: string = two()type error: Type 'number' is not assignable to type 'string'.TYPE UNIONS12345&gt; function isNumber(arg: number | string): boolean { return typeof arg === 'number' } [isNumber(1), isNumber('a')][true, false]LITERAL TYPES123456&gt; let one: 1 = 1 one1 &gt; let one: 1 = 2 onetype error: Type '2' is not assignable to type '1'.CONDITIONAL NARROWING1234567&gt; function add1IfNumber(n: number | boolean) { // Without narrowing, \"n + 1\" would be a type error because we can't // add booleans. return (typeof n === 'number') ? n + 1 : n } [add1IfNumber(1), add1IfNumber(true)][2, true]TUPLES123456&gt; let numberAndString: [number, string] = [1, 'a'] numberAndString[1]'a' &gt; let numberAndString: [number, string] = [1, 2] numberAndString[1]type error: Type 'number' is not assignable to type 'string'.LITERAL OBJECT TYPES12345&gt; function extractEmail(hasEmail: {email: string}): string { return hasEmail.email } extractEmail({email: 'amir@example.com'})'amir@example.com'GENERIC ARRAYS1234&gt; let numbers: number[] = [1] let numbers2: Array&lt;number&gt; = numbers numbers2[1]OBJECT NARROWING123&gt; type HasName = {name: string} let amir: HasName = {name: 'Amir', admin: true}The extra \"admin\" property is discarded.NULLABILITY1234&gt; let numberMaybe: number | undefinednumberMaybe can be either a number or undefined. &gt; let numberMaybe: number | nullnumberMaybe can be either a number or null.GENERIC FUNCTIONS12345&gt; function first&lt;T&gt;(elements: Array&lt;T&gt;): T { return elements[0] } first&lt;boolean&gt;([true, false])trueFUNCTION TYPES123456&gt; function add1(n: number): number { return n + 1 } const myAdd1: (n: number) =&gt; number = add1 myAdd1(3)4ANY1234&gt; const n: any = 5 const s: string = n s5DISCRIMINATED UNIONS123456789&gt; type StartedCourse = { started: true, lastInteractionTime: Date, } type UnstartedCourse = { started: false, } type Course = StartedCourse | UnstartedCourseVariables of type Course must match either the StartedCourse type or the UnstartedCourse type.LOGICAL OPERATOR NARROWING123456789101112131415&gt; function arrayLength(strings: string[] | undefined): number | undefined { return strings &amp;&amp; strings.length } [arrayLength(['a', 'b']), arrayLength(undefined)][2, undefined] &gt; function numberOrOne(n: number | undefined): number { return n || 1 } [numberOrOne(3), numberOrOne(undefined)][3, 1] &gt; function lengthOrNumber(n: number | number[]): number { return Array.isArray(n) ? n.length : n } [lengthOrNumber([1, 2]), lengthOrNumber(5)][2, 5]TYPE INTERSECTIONS1234&gt; type HasEmail = {email: string} type CanBeAdmin = {admin: boolean} type User = HasEmail &amp; CanBeAdminA User has both an email property and an admin property.FUNCTIONS AS ARGUMENTS123456789101112131415&gt; type TakesNumberReturnsNumber = (x: number) =&gt; number function add1(x: number): number { return x + 1 } const arrayOfFunctions: TakesNumberReturnsNumber[] = [add1] const aFunction: TakesNumberReturnsNumber = arrayOfFunctions[0] aFunction(2)3 &gt; function callFunction(f: () =&gt; number) { return f() } callFunction( () =&gt; 3 )3ERROR HANDLING WITH UNIONS1234567891011&gt; type ConversionSucceeded = { kind: 'success', value: number, } type ConversionFailed = { kind: 'failure', reason: string, } type ConversionResult = ConversionSucceeded | ConversionFailed function safeNumber(s: string): ConversionResult { ... }Force callers to handle failures.UNKNOWN12345678&gt; const n: unknown = 5 const n2: number = n n2type error: Type 'unknown' is not assignable to type 'number'. &gt; const n: unknown = 5 const n2: number = typeof n === 'number' ? n : 0 n25VOID1234&gt; function f() { } const n: number = f()type error: Type 'void' is not assignable to type 'number'.UNDEFINED IN ARRAYS123&gt; let strings: string[] = [] strings[1]undefinedGENERIC OBJECT TYPES12345678910&gt; type Pants&lt;T1, T2&gt; = { left: T1, right: T2, } let myPants: Pants&lt;string, number&gt; = { left: 'phone', right: 5, } myPants.left'phone'GENERIC FUNCTION TYPES1234567&gt; function first&lt;T&gt;(elements: Array&lt;T&gt;): T { return elements[0] } type First&lt;T&gt; = (elements: Array&lt;T&gt;) =&gt; T const firstString: First&lt;string&gt; = first firstString(['a', 'b', 'c'])'a'TYPE PREDICATES1234567&gt; function isString(s: unknown): s is string { return typeof s === 'string' } const s: unknown = 'a string' const s2: string = isString(s) ? s : '' s2'a string'INDEX SIGNATURES12345678910&gt; const strings: {[index: number]: string} = ['a', 'b', 'c'] strings['a', 'b', 'c'] &gt; type LoginCounts = {[userName: string]: number} const loginCounts: LoginCounts = { Amir: 5, Betty: 7, } loginCounts.Betty7GENERIC FUNCTION INFERENCE12345&gt; function length&lt;T&gt;(elements: T[]): number { return elements.length } length([1, 2])2SHARED FIELDS1234&gt; type HasEmail = {email: string} type User = HasEmail &amp; {admin: boolean} type Company = HasEmail &amp; {accountNumber: number}Users and Companies both have an email property.OPTIONAL CHAINING123456789101112&gt; type User = {name: string} function getUser(): User | undefined { return {name: 'Amir'} } getUser()?.name'Amir' &gt; type User = {name: string} function getUser(): User | undefined { return undefined } getUser()?.nameundefinedNULLISH COALESCING123456&gt; null ?? 11 &gt; undefined ?? 11 &gt; false ?? 1falseASSERTION FUNCTIONS12345678910&gt; function assert(condition: boolean): asserts condition { if (!condition) { throw new Error('Assertion failed') } } const var1: number | string = ((): number | string =&gt; 1)() assert(typeof var1 === 'number') const var2: number = var1 var21NEVER12345&gt; function throws(): never { throw new Error('oh no') } throws()Error: oh noRECURSIVE TYPES1234&gt; type NestedNumberArray = number | NestedNumberArray[] const n: NestedNumberArray = [[[[1]], 2, [3]]] n[[[[1]], 2, [3]]]RegexLITERALS12&gt; /a/(matches 'a')WILDCARD12&gt; /./(matches anything)BOUNDARIES1234&gt; /^/(matches start of string) &gt; /$/(matches end of string)REPETITION1234&gt; /a+/(matches one or more 'a') &gt; /a*/(matches zero or more 'a')OR12&gt; /a|b/(matches 'a' or 'b')PARENS12&gt; /^(a|b)+$/(matches a, b, ab, ba, ...)ESCAPING1234&gt; /\\+/(matches '+') &gt; /\\$/(matches '$')BASIC CHARACTER SETS1234&gt; /[ab]/(matches 'a' or 'b') &gt; /[a-z]/(matches lowercase letters)BASIC CHARACTER CLASSES123456&gt; /\\s/(matches whitespace) &gt; /\\d/(matches digits) &gt; /\\D/(matches not-digits)CHARACTER CLASSES12&gt; /\\w/(matches identifiers)CHARACTER SETS1234&gt; /[$]/(matches '$') &gt; /[a^]/(matches 'a' and '^')MAYBE12&gt; /a?/(matches 'a' or '')CONSTRAINED REPETITION123456&gt; /a{3}/(matches exactly three \"a\"s) &gt; /a{3,5}/(matches between 3 and 5 \"a\"s) &gt; /a{3,}/(matches at least 3 \"a\"s)WORD BOUNDARIES12&gt; /\\b/(matches word boundary)HEX CODES12&gt; /\\xhh/(matches hex codes)CHARACTER CLASSES IN SETS12&gt; /[\\s-]/(matches whitespace or '-')","link":"/2020/05/03/JavaScript%E6%89%8B%E5%86%8C2%E2%80%94%E2%80%94TypeScipt/"},{"title":"初识IPv6","text":"偶然发现家里用的宽带已经支持IPv6, 折腾下看看……这两天偶然发现家里用的浙江联通宽带已经支持IPv6，虽然我的无线路由器还不支持，但是网线直连光猫的电脑已经可以看到分配的IPv6地址。什么是IPv6自己看维基百科 https://zh.wikipedia.org/wiki/IPv6我的IPv6网络信息出于安全隐私考虑，本文中的IP地址都被“修饰”过通过https://test-ipv6.com/这个网站可以查看自己网络对于ipv6的支持情况，下图是我的网络测试情况：再看下以太网适配器的配置信息：12345连接特定的 DNS 后缀 . . . . . . . :IPv6 地址 . . . . . . . . . . . . : 2408:8360:729:a000:b512:46b1:420c:9da8临时 IPv6 地址. . . . . . . . . . : 2408:8360:729:a000:c027:5ee8:d275:c280本地链接 IPv6 地址. . . . . . . . : fe80::b512:46b1:420c:9da8%6IPv4 地址 . . . . . . . . . . . . : 192.168.1.3值得注意的是，这台设备被分配了2个全球单播地址（IPv6地址和临时IPv6地址）和1个链路本地地址，并有如下特征：IPv6地址和临时IPv6地址的前缀是一样的2408:8360:729:a000本地链接 IPv6前缀为fe80::，后缀和IPv6地址是一样的b512:46b1:420c:9da在test-ipv6网站中显示的地址是临时IPv6地址再来看下光猫里的配置信息：注意这里面的获取前缀2408:8360:729:a000::/60，表明着运营商分配的前缀长度是60位，剩余的68位地址就是我们的子网容量，这也就意味着在这个光猫下可以容纳2的68次方个地址！给家里每一粒灰层分配一个估计都用不完。深入理解IPv6现在我们对IPv6有了直观的认识，接下来看看这128位地址究竟是如何生成的，以及三个不同的IPv6地址分别有什么作用。IPv6地址格式IPv6二进位制下为128位长度，以16位为一组，每组以冒号“:”隔开，可以分为8组，每组以4位十六进制方式表示。例如：2001:0db8:86a3:08d3:1319:8a2e:0370:7344 是一个合法的IPv6地址。IPv6地址生成方法IPv6支持无状态配置（SLAAC），网络接口接上后能自动生成若干个地址，地址一般分为网络段和主机段，各占64位。IPv6地址分配机制只管高64位的分配，低64位的标识符（主机段）则由主机自己来保证唯一性。标识符的生成算法包括但不限于：EUI-64规则根据MAC地址生成，用于一般局域网或者物联网（Windows XP, Windows Server 2003及大多数Linux发行版都采用这种方式生成）低碰撞的随机数算法随机生成，用于生成临时地址实现隐私扩展（出于安全考虑，Windows Vista及之后的Windows系统都默认采用随机算法）人工配置保证唯一，用于配置一个服务器集群anycast地址，全0，本来就可以多路访问IPv6隐私扩展当一个客户端使用SLAAC配置其IPv6时，它会使用网络前缀和网卡的MAC地址构造地址。这会引起安全问题：计算机的MAC地址可以轻松通过其IPv6地址推算出，即使漫游到其他物理位置，由于MAC地址的全球唯一性，依然可以定位到客户端的设备。IPv6实现了一种使用临时地址访问服务器的方式：在连接远程服务器时，内核会从原本的IPv6地址计算生成一个“临时地址”，系统会优先选择这个地址以隐藏原来的地址。每一个时刻只有一个临时地址是有效的，在一个地址过期时会立刻生成一个新的地址作为新的临时地址。三个地址的作用本地链路地址：用于本地网络通信和网络配置临时全球地址：用于对外访问固定全球地址：可用于固定监听外部对你的访问有什么用呢有了IPv6地址，意味着联网的设备不再是隐藏在NAT后面，而是全都具有公网IP。有了公网IP，那是不是可以直接在电脑上搭建提供Web服务呢？启动个简单的web服务来试一下看到这个打印信息就觉得不太行，似乎只支持IPv4，通过浏览器分别访问下IPv6地址果然不行换成Caddy试试服务启动好了，浏览器里访问试一下，可以了在本机上三种IPv6地址都能访问，通过手机4G测试在外网IPv6地址和临时IPv6地址均能访问成功。看起来ISP还没有针对80端口进行封禁，不过经过这两天观察，光猫上分配的前缀是会变化的，如果想搭建网站或者服务需要采用DDNS等手段，有空了再试。安全性问题通过上面的测试我意识到一个问题，那就是我的设备端口现在等于直接暴露在公网环境中，我随便起了个Web服务就能在公网中访问到，如果有什么漏洞真是不堪设想。那是不是以后开发本地启动项目暴露的端口，也直接在公网上可以访问，不过现在Win10默认自带防火墙，开启如下设置即可。按理说阻止入站连接应该是路由器的默认防火墙安全级别，很遗憾联通的这个光猫似乎并没有防火墙。","link":"/2020/01/05/%E5%88%9D%E8%AF%86IPv6/"},{"title":"套接字接口","text":"本文介绍了套接字接口，并通过一个示例Java程序展示了应用程序如何调用操作系统套接字接口进行网络通信。Network socket在操作系统中，通常会为应用程序提供一组应用程序接口（API），称为套接字接口（英语：socket API）。应用程序可以通过套接字接口，来使用网络套接字，以进行数据交换。最早的套接字接口来自于4.2 BSD，因此现代常见的套接字接口大多源自Berkeley套接字（Berkeley sockets）标准。在套接字接口中，以IP地址及端口组成套接字地址（socket address）。远程的套接字地址，以及本地的套接字地址完成连线后，再加上使用的协议（protocol），这个五元组（five-element tuple），作为套接字对（socket pairs），之后就可以彼此交换数据。例如，在同一台计算机上，TCP协议与UDP协议可以同时使用相同的port而互不干扰。 操作系统根据套接字地址，可以决定应该将数据送达特定的行程或线程。——维基百科从Linux内核角度，socket是通信的一个端点，从Linux程序的角度看，socket是一个有相应描述符的打开文件。Java程序中的网络通信是如何与内核交互的？我们先来看一段简单的Java程序，功能很简单，在8888端口启动监听并把客户端发送的数据打印出来12345678910111213import java.io.BufferedReader;import java.io.InputStreamReader;import java.net.ServerSocket;import java.net.Socket;public class TestSocket { public static void main(String[] args) throws Exception { ServerSocket server = new ServerSocket(8888); Socket client = server.accept(); BufferedReader buf = new BufferedReader(new InputStreamReader(client.getInputStream())); System.out.println(buf.readLine()); }}在Linux上使用strace跟踪程序运行中发生的系统调用，strace - trace system calls and signals-f 同时监控fork出来的线程-t 打印时间-e network 只打印网络相关的系统调用1、sudo strace -ft -e network java TestSocket演示程序启动后分别调用了 socket -&gt; bind -&gt; listen2、新开一个终端，执行nc localhost 8888服务端启动后阻塞在accept中，直至和客户端建立连接3、客户端发送hahaha，服务端打印出内容如果查看相应pid下的文件描述符，也能看到相应的socket也就是说，我们的应用程序要进行网络通信，都是通过系统的socket interface调用。","link":"/2020/04/05/%E5%A5%97%E6%8E%A5%E5%AD%97%E6%8E%A5%E5%8F%A3/"},{"title":"常用的分布式事务解决方案","text":"为什么会产生分布式问题，有哪些常见的解决方案？1. 什么是分布式事务问题随着业务需求和架构的变化，单体应用被拆分为微服务，一个大型业务系统往往由若干个子系统构成，这些子系统又拥有各自独立的数据库。往往一个业务流程需要由多个子系统共同完成，而且这些操作可能需要在一个事务中完成。此时，每一个服务内部的数据一致性仍由本地事务来保证，整个业务层面的全局数据一致性就需要一个分布式事务的解决方案来保证。2. 分布式事务分类2.1 刚性分布式事务满足传统事务特性ACIDXA模型X/Open 组织（即现在的 Open Group ）定义了分布式事务处理模型XA应用程序（AP）定义事务边界并访问事务边界内的资源资源管理器（RM）管理计算机共享的资源，即数据库等事务管理器（TM）负责管理全局事务，分配事务唯一标志，监控事务的执行进度，负责事务的提交、回滚、失败恢复等2PC要求数据库提供对 XA 的支持，锁定周期长，并且需要应用服务器支持如WebLogic/WebSphere二阶段提交，是XA规范标准实现TM发起prepare投票RM都同意后，TM再发起commitCommit过程出现宕机等异常，节点服务重启后，根据XA recover再次进行commit补偿2.2 柔性分布式事务柔性事务是对XA协议的妥协，通过降低强一致性要求，从而降低数据库资源锁定时间，提升可用性TCC模型完全由业务实现，每个子业务都需要实现Try-Confirm-Cancel三个接口，对业务侵入大Try 尝试执行业务，执行业务检查，预留必要的业务资源Confirm：真正执行业务，不再做业务检查Cancel：释放Try阶段预留的业务资源Saga模型把一个分布式事务拆分为多个本地事务，每个本地事务都有相应的执行模块和补偿模块，当Saga中任意一个本地事务出错时，可以通过调用相关的补偿方法恢复之前的事务。当每个Saga子事务T1, T2, …,Tn都有对应的补偿定义C1, C2, …,Cn-1，则有最佳情况：子事务序列T1, T2, …,Tn全部完成失败恢复：T1, T2, …,Tj, Cj-1, …, C2, C1 得以完成Saga隔离性Saga本身不保证隔离性，需由业务层控制并发：加锁或者预先冻结资源Saga恢复方式向后恢复：补偿所有已完成的事务向前恢复：重试失败的事务，假设每个子事务最终都会成功2.3 刚性分布式事务VS柔性分布式事务刚性事务（XA）柔性事务业务改造无有回滚支持实现补偿接口一致性强一致性最终一致性隔离性原生支持实现资源锁定接口并发性能严重衰退略微衰退适合场景短事务，低并发长事务，高并发3. 异步场景分布式事务设计3.1 可靠消息最终一致性MQ提供类似XA的分布式事务功能，发送方在业务执行开始会先向消息队列中投递 “半消息”，半消息即“暂不能投递”状态的消息，需要发送方根据本地事务执行的结果向MQ服务提交二次确认，才会执行发送或者删除消息的操作。优点：较为通用缺点：业务方需要提供回查接口，发送消息At least once，消费端需处理幂等，MQ需支持事务消息3.2 本地事务消息表本地操作和发送消息通过本地事务强一致性。本地事务提交时，将业务数据和消息数据一同写入本地数据库，再从消息表读取消息写入MQ。优点：业务侵入性小，无需MQ支持事务消息缺点：发送端消息At least once，消费端需处理幂等4. 同步场景分布式事务设计4.1 基于异步补偿的分布式事务记录请求调用链条+提供幂等补偿接口+补偿机制。基本原理通过一个分布式事务补偿服务，记录全局事务组和请求调用参数在远端数据库TDB在真正业务逻辑被调用前，生成一个全局唯一的TXID标识事务组-&gt;TDB在调用数据访问层之前记录当前调用请求参数-&gt;TDB业务正常：调用完成后，当前的调用记录存档或删除业务异常：查询调用链反向补偿4.2 seata（Fescar）可参考阿里巴巴开源的分布式事务中间件Fescar，https://github.com/seata/seata/wiki/%E6%A6%82%E8%A7%88类似上述基于异步补偿的分布式事务，但Fescar的 JDBC 数据源代理通过对业务 SQL 的解析，把业务数据在更新前后的数据镜像组织成回滚日志，在回滚时通过回滚日志生成反向的更新 SQL 并执行，无需额外提供补偿接口，对业务无侵入性。","link":"/2019/06/18/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"title":"线上问题定位分析方法","text":"一些常见的Java应用问题排查工具和问题排查思路。1. Java线程堆栈jstack 用于生成java虚拟机当前时刻的线程快照。线程快照是当前java虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等。1.1 Java线程JVM创建的线程Attach Listener、Signal Dispatcher、Low Memory Detector、CompilerThread0、FinalizerJava用户线程排查问题时主要关注的地方线程堆栈第一行tid可以理解为语言层面的线程idnid(Native Thread)是JVM的本地线程堆栈pstack {Java进程号}nid(16进制) == LWP(10进制)线程调用含义1.2 锁一个线程占有一个锁时，堆栈会打印：locked &lt;0xe74023b9&gt;该线程等待别的线程释放锁时，堆栈会打印：waiting to lock &lt;0xe74023b9&gt;代码中有wait()调用，堆栈会打印：waiting on &lt;0xe74023b9&gt;1.3 线程状态线程状态执行操作cpu消耗RUNNABLE执行java代码、Native（网络IO）、JNI不确定cpu消耗TIMED_WAITING (on object monitor)obj.wait(time)不消耗cpuTIMED_WAITING (sleeping)Thread.sleep(time)不消耗cpuTIMED_WAITING (parking)被挂起不消耗cpuWAITING (on object monitor)obj.wait()不消耗cpuBLOCKED (on object monitor)等待监视锁不消耗cpu2. 分析性能瓶颈2.1 线程死锁分析线程死锁的原因很简单，两个线程各自持有锁，然后等待获取对方的锁。Java堆栈能直接给出结果1234567891011121314151617181920212223Found one Java-level deadlock:=============================&quot;Thread-0&quot;: waiting to lock monitor 0x000000002334a280 (object 0x00000000c7a49f40, a java.lang.Object), which is held by &quot;Thread-1&quot;&quot;Thread-1&quot;: waiting to lock monitor 0x000000002334a480 (object 0x00000000c7a49f30, a java.lang.Object), which is held by &quot;Thread-0&quot;Java stack information for the threads listed above:===================================================&quot;Thread-0&quot;: at SimpleDeadLock$Thread1.run(SimpleDeadLock.java:23) - waiting to lock &lt;0x00000000c7a49f40&gt; (a java.lang.Object) - locked &lt;0x00000000c7a49f30&gt; (a java.lang.Object)&quot;Thread-1&quot;: at SimpleDeadLock$Thread2.run(SimpleDeadLock.java:36) - waiting to lock &lt;0x00000000c7a49f30&gt; (a java.lang.Object) - locked &lt;0x00000000c7a49f40&gt; (a java.lang.Object)Found 1 deadlock.2.2 代码死循环导致CPU过高分析常见原因HashMap等线程不安全容器，多线程并发读写共享变量没有加锁，多线程并发读写，while、for等退出条件不满足定位方法一获取一次堆栈间隔一定时间再次获取堆栈去除掉wait、sleep的线程比较两次堆栈，找出一直活跃的线程定位方法二ps -aux |grep 进程名，得到[java进程号]top -p [java进程号]shift+h 打印出所有线程的CPU统计找出cpu占用率高的线程pid(LWP)LWP=nid在堆栈信息中找出对应的java线程2.3 资源不足导致的性能下降大量的线程停在同样的调用上下文上原因：资源配置过少，并发高线程占用资源时间过长代码设计不合理，没有及时释放资源异常情况下未关闭资源内存泄漏导致频繁gc3. 线上问题处理线上问题处理步骤：发现问题-&gt;保留现场-&gt;快速恢复-&gt;排查解决-&gt;验证3.1 问题定位如果有日志报错，则能很好的定位问题，只需根据报错的堆栈信息来解决问题即可；如果日志没有任何异常信息：检查最近是否有版本发布、服务调用量情况、服务吞吐量和时延、服务器监控指标等保存现场3.2 保存现场在重启服务前进行保存现场操作，包括保存当前线程的快照和保存JVM内存堆栈快照：保存当前运行线程的快照，可以使用jstack [pid]命令实现，在通常情况下需要保存三份不同时刻的线程快照，时间间隔为1～2分钟。保存JVM内存堆栈快照，可以使用jmap –heap、jmap –histo、jmap -dump:format=b、file=xxx.hprof等命令实现。如果线上服务器资源较多，也可以隔离出1~2台服务器，用作后续问题重现和排查3.3 快速恢复根据定位情况决定采取回退版本、紧急修复、服务扩容降级、服务熔断等手段，优先保证线上服务正常运行3.4 排查解决经过上面的一系列操作，线上服务已经暂时恢复，接下来需要排查问题所在服务器层面排查主要是CPU、内存、网络连接、磁盘等指标topfree -hnetstat -antp |grep ESTABLISHED |wc -liostat -d 1java进程层面的排查4. 为故障和失败做设计错误无法避免，故障发生时尽可能维持系统核心功能的可用性设置合理的超时机制自身服务的降级策略对依赖服务的熔断策略","link":"/2019/07/01/%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/"},{"title":"缓存数据一致性","text":"我们使用缓存来降低请求的响应时间，分布式缓存怎么做（Redis Cluster和Codis），数据一致性如何保证？1. 缓存介绍1.1 为什么使用缓存降低请求的响应时间，提升用户体验，减少对固化存储的读压力1.2 缓存适用场景静态资源较少更改的资源读多写少1.3 缓存类别本地缓存作用静态不变的数据减少网络I/O交互例如：电商网站的分类信息Google Guava Cache分布式缓存作用缓存相对静态的数据缓存数据量较大，单机无法存放的数据提高查询速度Memcached、Redis2 分布式缓存实现2.1 Redis ClusterRedis Cluster 是 Redis 的分布式解决方案，在 3.0 版本正式推出，有效地解决了 Redis 分布式方面的需求。数据分片Sharding采用预分配16384个槽slot，根据crc16(key) mod 16384的值，决定key存放在哪个slot里；集群只有在所有槽位都有主节点处理时才能上线并处理数据。命令执行槽位正确：命令处理的key正好由接受命令的节点负责，直接处理；槽位不正确：key所在的槽并非由当前节点负责，向客户端返回Redirection，客户端根据Redirection转至新节点。Redirection实现Gossip协议（最终一致性算法）包含多种消息，包括ping，pong，meet，fail等等，用于失败检测、路由同步、Pub/Sub、动态负载均衡等节点间通过Gossip协议通信，每个节点都知道集群中包含哪些节点，以及这些节点的状态故障转移部署时通常需要把节点部署成主从模式，以便在故障时快速恢复集群中某主节点宕机从宕机节点所有从节点选择一个节点该从节点执行SLAVEOF onone命令，成为新的主节点新的主节点会撤销所有对宕机节点的槽指派，并全部指派给自己新的主节点向集群广播PONG消息新的主节点开始接受并处理自己负责的槽有关的命令2.2 Codis和Redis cluster不同，Codis采用一层无状态的proxy层，将分布式逻辑写在proxy上，底层的存储引擎还是Redis本身，数据的分布状态存储于zookeeper(etcd)中。数据分片：Codis 采用 Pre-sharding 的技术来实现数据的分片，默认分成 1024 个 slots (0-1023)，SlotId = crc32(key) % 1024支持动态水平扩展，对client完全透明不影响服务的情况下可以完成增减redis实例的操作故障转移：Redis主从使用Redis的Sentinel监控，发现问题后触发更改metadata负载均衡：提供了运维工具自动rebalance slot运维工具、图形监控界面3 缓存数据一致性数据多份存储：数据库、缓存，如何保证数据库与缓存的一致性强一致性？通过2PC等实现强一致性，不适用互联网业务高吞吐量、低延迟的要求时序控制？先删除缓存，然后再更新数据库，而后续的操作会把数据再装载的缓存中。看起来没有问题，但是假如两个并发操作，一个是更新操作，另一个是查询操作，更新操作删除缓存后，查询操作没有命中缓存，先把老数据读出来后放到缓存中，然后更新操作更新了数据库。于是，在缓存中的数据还是老的数据，导致缓存中的数据是脏的，而且还一直这样脏下去了。最终一致性保证读请求先读缓存，命中缓存则直接返回不命中，读数据库，把结果回填缓存中写请求更新数据库，然后立即delete缓存项X秒钟后，再次delete缓存项（双重失效，保证成功率）缓存delete失败的记录日志、脚本定期修正​设置缓存Expired Time根据业务特点设置同时要注意缓存集中失效的问题，可在过期时间上增加随机量","link":"/2019/05/19/%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/"}],"tags":[{"name":"JVM","slug":"JVM","link":"/tags/JVM/"},{"name":"GC","slug":"GC","link":"/tags/GC/"},{"name":"JS","slug":"JS","link":"/tags/JS/"},{"name":"网络","slug":"网络","link":"/tags/%E7%BD%91%E7%BB%9C/"},{"name":"socket","slug":"socket","link":"/tags/socket/"},{"name":"分布式","slug":"分布式","link":"/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"事务","slug":"事务","link":"/tags/%E4%BA%8B%E5%8A%A1/"},{"name":"缓存","slug":"缓存","link":"/tags/%E7%BC%93%E5%AD%98/"}],"categories":[]}